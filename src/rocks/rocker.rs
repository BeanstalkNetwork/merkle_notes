use super::{HashableElement, MerkleHasher};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use rocksdb::DB;
use std::{path::Path, sync::Arc};

const LEAF_COUNT_KEY: &str = "LeafCount";
const NODE_COUNT_KEY: &str = "NodeCount";
const LEAF_METADATA_PREFIX: &[u8; 8] = b"LeafData";
const LEAF_ELEMENT_PREFIX: &[u8; 11] = b"LeafElement";
const NODE_DATA_PREFIX: &[u8; 8] = b"NodeData";

/// Newtype wrapper to avoid mixing up leaf and node indexes
#[derive(Shrinkwrap, Debug, PartialEq, Copy, Clone)]
pub(crate) struct LeafIndex(pub(crate) u32);

impl LeafIndex {
    fn metadata_key(&self) -> Vec<u8> {
        let mut key = LEAF_METADATA_PREFIX.to_owned().to_vec();
        key.extend(u32_as_bytes(self.0));
        key
    }
    fn element_key(&self) -> Vec<u8> {
        let mut key = LEAF_ELEMENT_PREFIX.to_owned().to_vec();
        key.extend(u32_as_bytes(self.0));
        key
    }
}

impl PartialEq<u32> for LeafIndex {
    fn eq(&self, other: &u32) -> bool {
        self.0 == *other
    }
}

impl LeafIndex {
    pub(crate) fn is_right(&self) -> bool {
        self.0 % 2 == 1
    }

    /// Get the index of the sibling index. Note that this
    /// makes no guarantees as to whether the sibling leaf exists.
    pub(crate) fn sibling(&self) -> LeafIndex {
        if self.is_right() {
            LeafIndex(self.0 - 1)
        } else {
            LeafIndex(self.0 + 1)
        }
    }
}

/// Newtype wrapper to avoid mixing up leaf and node indexes
#[derive(Shrinkwrap, Debug, PartialEq, Copy, Clone)]
pub(crate) struct NodeIndex(pub(crate) u32);
impl NodeIndex {
    pub(crate) fn empty() -> Self {
        NodeIndex(0)
    }

    pub(crate) fn is_empty(&self) -> bool {
        self.0 == 0
    }

    fn data_key(&self) -> Vec<u8> {
        let mut key = NODE_DATA_PREFIX.to_owned().to_vec();
        key.extend(u32_as_bytes(self.0));
        key
    }
}

/// Metadata about a leaf stored in rocksdb under the LeafData
/// key prefix. The element bytes are stored under a separate key.
#[derive(Debug, PartialEq)]
pub(crate) struct Leaf<T: MerkleHasher> {
    pub(crate) parent: NodeIndex,
    pub(crate) hash: <T::Element as HashableElement>::Hash,
}

/// Represent an internal node in the tree of nodes. To make it easy
/// to create an authentication path, internal nodes store the hash of their
/// *sibling* rather than their own hash.
#[derive(Debug, PartialEq)]
pub(crate) enum Node<T: MerkleHasher> {
    /// In the case of a left node, there may not be a right sibling.
    /// When we do that, the hash is generated by hashing with ourselves.
    /// So hash_of_sibling would happen to be "my own hash." The parent
    /// node could be None if this is the root node.
    Left {
        hash_of_sibling: <T::Element as HashableElement>::Hash,
        parent: NodeIndex,
    },
    /// A right node always has a left sibling (an append-only merkle
    /// tree fills from left to right). We keep a link to it
    /// instead of to the parent. The parent can be found through
    /// left.parent.
    Right {
        hash_of_sibling: <T::Element as HashableElement>::Hash,
        left: NodeIndex,
    },
    /// There is only one empty node, and it is the parent of the root
    /// node. It gets the honourary position `0`.
    Empty,
}

/// Rocksdb wrapper that queries and unwraps requests for specific
/// keys and types useful to the RocksMerkleTree.
///
/// This struct uses expect() everywhere. That's not particularly safe,
/// but I don't have a better idea. We can't expose the errors upward
/// because the MerkleTree trait doesn't have Results on it, and even if we could,
/// it's unclear how the client code would handle it. So we panic... *sigh*
pub(crate) struct Rocker<T: MerkleHasher> {
    hasher: Arc<T>,
    rocksdb: DB,
}

impl<T: MerkleHasher> Rocker<T> {
    pub(crate) fn new(hasher: Arc<T>, rocks_directory: &Path) -> Self {
        Rocker {
            hasher,
            rocksdb: DB::open_default(rocks_directory).expect("Unable to load database"),
        }
    }

    /// Retrieve the number of leaf nodes (notes) in the tree
    pub(crate) fn num_leaves(&self) -> u32 {
        self.get_u32(LEAF_COUNT_KEY).unwrap_or(0)
    }

    /// Set the number of leaf nodes. It may be good to have an atomic increment
    /// operation here, since it only ever goes up by one.
    pub(crate) fn set_num_leaves(&self, length: u32) {
        self.set_u32(LEAF_COUNT_KEY, length as u32);
    }

    /// Get the number of internal nodes. There is always at least one internal node
    /// (the empty node)
    pub(crate) fn num_nodes(&self) -> u32 {
        self.get_u32(NODE_COUNT_KEY).unwrap_or(1)
    }

    pub(crate) fn set_num_nodes(&self, count: u32) {
        self.set_u32(NODE_COUNT_KEY, count as u32);
    }

    /// Get the parent of the leaf node at given index.
    /// **Assumes that the leaf index actually exists in the tree.**
    /// This is a shortcut method when you know you'll unwrap the result
    pub(crate) fn get_leaf_parent(&self, index: LeafIndex) -> NodeIndex {
        self.get_leaf_metadata(index).unwrap().parent
    }

    /// Get the hash of the leaf at given index.
    /// **Assumes the leaf index exists in the tree**
    pub(crate) fn get_leaf_hash(&self, index: LeafIndex) -> <T::Element as HashableElement>::Hash {
        self.get_leaf_metadata(index).unwrap().hash
    }

    pub(crate) fn get_leaf_metadata(&self, index: LeafIndex) -> Option<Leaf<T>> {
        self.get(index.metadata_key(), |mut bytes| {
            let parent = NodeIndex(bytes.read_u32::<LittleEndian>().unwrap());
            let hash = self.hasher.read_hash(&mut bytes).unwrap();
            Leaf { parent, hash }
        })
    }

    pub(crate) fn set_leaf_metadata(&self, index: LeafIndex, value: &Leaf<T>) {
        let mut bytes = vec![];
        bytes.write_u32::<LittleEndian>(value.parent.0).unwrap();
        self.hasher.write_hash(&value.hash, &mut bytes).unwrap();
        self.rocksdb.put(index.metadata_key(), bytes).unwrap();
    }

    pub(crate) fn get_leaf_element(&self, index: LeafIndex) -> Option<T::Element> {
        self.get(index.element_key(), |mut bytes| {
            self.hasher.read_element(&mut bytes).unwrap()
        })
    }

    /// Get the index of the parent of the given node. If it's a left node, it has a parent,
    /// if it's a right node, we have to get the parent of its left sibling, if it's empty,
    /// the index is zero
    pub(crate) fn get_node_parent(&self, index: NodeIndex) -> NodeIndex {
        let node = self.get_node(index);
        match node {
            Node::Empty => NodeIndex::empty(),
            Node::Left { parent, .. } => parent,
            Node::Right { left, .. } => self.get_node_parent(left),
        }
    }

    /// Get the node at the given index. If index is 0, return Empty,
    /// otherwise load the given node from the database.
    ///
    /// Panics if the node does not exist. This is crate-internal and should
    /// never be called in a situation where the node does not exist.
    pub(crate) fn get_node(&self, index: NodeIndex) -> Node<T> {
        if index.0 == 0 {
            Node::Empty
        } else {
            self.get(index.data_key(), |mut bytes| {
                let node_type = bytes.read_u8().unwrap();
                let the_other_node = NodeIndex(bytes.read_u32::<LittleEndian>().unwrap());
                let hash_of_sibling = self.hasher.read_hash(&mut bytes).unwrap();
                if node_type == 0 {
                    Node::Left {
                        parent: the_other_node,
                        hash_of_sibling,
                    }
                } else {
                    Node::Right {
                        left: the_other_node,
                        hash_of_sibling,
                    }
                }
            })
            .unwrap()
        }
    }

    pub(crate) fn set_node(&self, index: NodeIndex, node: &Node<T>) {
        let data_key = index.data_key();
        let mut bytes = vec![];
        match (index, node) {
            (NodeIndex(0), Node::Empty) => return,
            (NodeIndex(0), _) => panic!("Trying to set empty node at position other than 0"),
            (NodeIndex(_), Node::Empty) => panic!("Trying to set non empty node at position 0"),
            (
                NodeIndex(_),
                Node::Left {
                    hash_of_sibling,
                    parent,
                },
            ) => {
                bytes.write_u8(0).unwrap();
                bytes.write_u32::<LittleEndian>(parent.0).unwrap();
                self.hasher
                    .write_hash(&hash_of_sibling, &mut bytes)
                    .unwrap();
            }
            (
                NodeIndex(_),
                Node::Right {
                    hash_of_sibling,
                    left,
                },
            ) => {
                bytes.write_u8(1).unwrap();
                bytes.write_u32::<LittleEndian>(left.0).unwrap();
                self.hasher
                    .write_hash(&hash_of_sibling, &mut bytes)
                    .unwrap();
            }
        }
        self.rocksdb.put(data_key, bytes).unwrap();
    }
    pub(crate) fn set_leaf_element(&self, index: LeafIndex, value: &T::Element) {
        let mut bytes = vec![];
        value.write(&mut bytes).unwrap();
        self.rocksdb.put(index.element_key(), bytes).unwrap();
    }

    fn get<K: AsRef<[u8]>, V, F: FnOnce(&[u8]) -> V>(&self, key: K, callback: F) -> Option<V> {
        self.rocksdb
            .get_pinned(key)
            .unwrap()
            .map(|pinnable_slice| callback(pinnable_slice.as_ref()))
    }

    fn get_u32(&self, key: &str) -> Option<u32> {
        self.get(key, |mut bytes| bytes.read_u32::<LittleEndian>().unwrap())
    }

    fn set_u32(&self, key: &str, value: u32) {
        let mut bytes = vec![];
        bytes.write_u32::<LittleEndian>(value).unwrap();
        self.rocksdb.put(key, bytes).unwrap();
    }
}

fn u32_as_bytes(value: u32) -> Vec<u8> {
    let mut bytes: Vec<u8> = vec![];
    bytes.write_u32::<LittleEndian>(value).unwrap();
    bytes
}
