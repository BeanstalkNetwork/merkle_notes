//! Sled wrapper that queries and unwraps requests for specific
//! keys and types useful to the SledMerkleTree.
//!
//! This module uses expect() everywhere. That's not particularly safe,
//! but I don't have a better idea. We can't expose the errors upward
//! because the MerkleTree trait doesn't have Results on it, and even if we could,
//! it's unclear how the client code would handle it. So we panic... *sigh*
//!
//! Accepts db from
use super::{HashableElement, MerkleHasher};
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use sled;
use std::sync::Arc;

/// Newtype wrapper to avoid mixing up leaf and node indexes
#[derive(Shrinkwrap, Debug, PartialEq, Copy, Clone)]
pub(crate) struct LeafIndex(pub(crate) u32);

impl LeafIndex {
    fn key(&self, suffix: &[u8]) -> Vec<u8> {
        let mut key = b"Leaf".to_vec();
        key.extend(&self.0.to_be_bytes());
        key.extend(suffix);
        key
    }

    fn parent_key(&self) -> Vec<u8> {
        self.key(b"Parent")
    }

    fn element_key(&self) -> Vec<u8> {
        self.key(b"Element")
    }
    fn hash_key(&self) -> Vec<u8> {
        self.key(b"Hash")
    }
}

impl PartialEq<u32> for LeafIndex {
    fn eq(&self, other: &u32) -> bool {
        self.0 == *other
    }
}

impl LeafIndex {
    pub(crate) fn is_right(&self) -> bool {
        self.0 % 2 == 1
    }

    /// Get the index of the sibling index. Note that this
    /// makes no guarantees as to whether the sibling leaf exists.
    pub(crate) fn sibling(&self) -> LeafIndex {
        if self.is_right() {
            LeafIndex(self.0 - 1)
        } else {
            LeafIndex(self.0 + 1)
        }
    }
}

/// Newtype wrapper to avoid mixing up leaf and node indexes
#[derive(Shrinkwrap, Debug, PartialEq, Copy, Clone)]
pub(crate) struct NodeIndex(pub(crate) u32);
impl NodeIndex {
    pub(crate) fn empty() -> Self {
        NodeIndex(0)
    }

    pub(crate) fn is_empty(&self) -> bool {
        self.0 == 0
    }

    fn key(&self) -> Vec<u8> {
        let mut key = b"Node".to_vec();
        key.extend(&self.0.to_be_bytes());
        key
    }
}

/// Represent an internal node in the tree of nodes. To make it easy
/// to create an authentication path, internal nodes store the hash of their
/// *sibling* rather than their own hash.
#[derive(Debug, PartialEq)]
pub(crate) enum Node<T: MerkleHasher> {
    /// In the case of a left node, there may not be a right sibling.
    /// When we do that, the hash is generated by hashing with ourselves.
    /// So hash_of_sibling would happen to be "my own hash." The parent
    /// node could be None if this is the root node.
    Left {
        hash_of_sibling: <T::Element as HashableElement>::Hash,
        parent: NodeIndex,
    },
    /// A right node always has a left sibling (an append-only merkle
    /// tree fills from left to right). We keep a link to it
    /// instead of to the parent. The parent can be found through
    /// left.parent.
    Right {
        hash_of_sibling: <T::Element as HashableElement>::Hash,
        left: NodeIndex,
    },
    /// There is only one empty node, and it is the parent of the root
    /// node. It gets the honourary position `0`.
    Empty,
}

pub(crate) struct Sledder<'a, T: MerkleHasher> {
    hasher: Arc<T>,
    counters: &'a sled::TransactionalTree,
    leaves: &'a sled::TransactionalTree,
    nodes: &'a sled::TransactionalTree,
}

impl<'a, T: MerkleHasher> Sledder<'a, T> {
    pub(crate) fn new(
        hasher: Arc<T>,
        counters: &'a sled::TransactionalTree,
        leaves: &'a sled::TransactionalTree,
        nodes: &'a sled::TransactionalTree,
    ) -> Self {
        Sledder {
            hasher,
            counters,
            leaves,
            nodes,
        }
    }
    /// Retrieve the number of leaf nodes (notes) in the tree
    pub(crate) fn num_leaves(&self) -> u32 {
        self.get_u32(self.counters, b"LeafCount").unwrap_or(0)
    }

    /// Set the number of leaf nodes. .
    pub(crate) fn set_num_leaves(&self, length: u32) {
        self.set_u32(self.counters, b"LeafCount", length as u32);
    }

    /// Get the number of internal nodes. There is always at least one internal node
    /// (the empty node)
    pub(crate) fn num_nodes(&self) -> u32 {
        self.get_u32(self.counters, b"NodeCount").unwrap_or(1)
    }

    pub(crate) fn set_num_nodes(&self, count: u32) {
        self.set_u32(self.counters, b"NodeCount", count as u32);
    }

    /// Get the parent of the leaf node at given index.
    pub(crate) fn leaf_parent(&self, index: LeafIndex) -> Option<NodeIndex> {
        self.get_u32(self.leaves, &index.parent_key())
            .map(|num| NodeIndex(num))
    }

    /// Set the parent of the given index.
    pub(crate) fn set_leaf_parent(&self, index: LeafIndex, parent: NodeIndex) {
        self.set_u32(self.leaves, &index.parent_key(), parent.0)
    }

    /// Get the hash of the leaf at given index.
    /// **Assumes the leaf index exists in the tree**
    pub(crate) fn leaf_hash(
        &self,
        index: LeafIndex,
    ) -> Option<<T::Element as HashableElement>::Hash> {
        self.leaves.get(index.hash_key()).unwrap().map(|ivec| {
            let mut bytes = &ivec[..];
            self.hasher.read_hash(&mut bytes).unwrap()
        })
    }

    /// Set the hash at the given index.
    pub(crate) fn set_leaf_hash(
        &self,
        index: LeafIndex,
        hash: &<T::Element as HashableElement>::Hash,
    ) {
        let mut bytes = vec![];
        self.hasher.write_hash(hash, &mut bytes).unwrap();
        self.leaves.insert(index.hash_key(), bytes).unwrap();
    }

    /// Get the element at a given index. Return None if it does not exist.
    pub(crate) fn leaf_element(&self, index: LeafIndex) -> Option<T::Element> {
        self.leaves
            .get(index.element_key())
            .unwrap()
            .map(|bytes_vec| {
                let mut bytes = &bytes_vec[..];
                self.hasher.read_element(&mut bytes).unwrap()
            })
    }

    pub(crate) fn set_leaf_element(&self, index: LeafIndex, value: &T::Element) {
        let mut bytes = vec![];
        value.write(&mut bytes).unwrap();
        self.leaves.insert(index.element_key(), bytes).unwrap();
    }

    /// Get the index of the parent of the given node. If it's a left node, it has a parent,
    /// if it's a right node, we have to get the parent of its left sibling, if it's empty,
    /// the index is zero
    pub(crate) fn node_parent(&self, index: NodeIndex) -> NodeIndex {
        let node = self.node(index);
        match node {
            Node::Empty => NodeIndex::empty(),
            Node::Left { parent, .. } => parent,
            Node::Right { left, .. } => self.node_parent(left),
        }
    }

    /// Get the node at the given index. If index is 0, return Empty,
    /// otherwise load the given node from the database.
    ///
    /// Panics if the node does not exist. This is crate-internal and should
    /// never be called in a situation where the node does not exist.
    pub(crate) fn node(&self, index: NodeIndex) -> Node<T> {
        if index.0 == 0 {
            Node::Empty
        } else {
            self.nodes
                .get(index.key())
                .unwrap()
                .map(|bytes_vec| {
                    let mut bytes = &bytes_vec[..];
                    let node_type = bytes.read_u8().unwrap();
                    let the_other_node = NodeIndex(bytes.read_u32::<BigEndian>().unwrap());
                    let hash_of_sibling = self.hasher.read_hash(&mut bytes).unwrap();
                    if node_type == 0 {
                        Node::Left {
                            parent: the_other_node,
                            hash_of_sibling,
                        }
                    } else {
                        Node::Right {
                            left: the_other_node,
                            hash_of_sibling,
                        }
                    }
                })
                .unwrap()
        }
    }

    pub(crate) fn set_node(&self, index: NodeIndex, node: &Node<T>) {
        let data_key = index.key();
        let mut bytes = vec![];
        match (index, node) {
            (NodeIndex(0), Node::Empty) => return,
            (NodeIndex(0), _) => panic!("Trying to set empty node at position other than 0"),
            (NodeIndex(_), Node::Empty) => panic!("Trying to set non empty node at position 0"),
            (
                NodeIndex(_),
                Node::Left {
                    hash_of_sibling,
                    parent,
                },
            ) => {
                bytes.write_u8(0).unwrap();
                bytes.write_u32::<BigEndian>(parent.0).unwrap();
                self.hasher
                    .write_hash(&hash_of_sibling, &mut bytes)
                    .unwrap();
            }
            (
                NodeIndex(_),
                Node::Right {
                    hash_of_sibling,
                    left,
                },
            ) => {
                bytes.write_u8(1).unwrap();
                bytes.write_u32::<BigEndian>(left.0).unwrap();
                self.hasher
                    .write_hash(&hash_of_sibling, &mut bytes)
                    .unwrap();
            }
        }
        self.nodes.insert(data_key, bytes).unwrap();
    }

    fn get_u32(&self, db: &sled::TransactionalTree, key: &[u8]) -> Option<u32> {
        let bytes_option = db.get(key).unwrap();
        bytes_option.map(|bytes_vec| {
            assert_eq!(bytes_vec.len(), 4);
            let mut bytes = [0; 4];
            bytes[0..4].clone_from_slice(&bytes_vec);
            u32::from_be_bytes(bytes)
        })
    }

    fn set_u32(&self, db: &sled::TransactionalTree, key: &[u8], value: u32) {
        let bytes = value.to_be_bytes();
        db.insert(key, &bytes).unwrap();
    }
}

/// Helper method to get the leaf count outside a transaction
pub(crate) fn num_leaves(db: &sled::Tree) -> u32 {
    let key = b"LeafCount";
    db.get(key)
        .unwrap()
        .map(|bytes_vec| {
            assert_eq!(bytes_vec.len(), 4);
            let mut bytes = [0; 4];
            bytes[0..4].clone_from_slice(&bytes_vec);
            u32::from_be_bytes(bytes)
        })
        .unwrap_or(0)
}

#[cfg(test)]
pub(crate) fn num_nodes(db: &sled::Tree) -> u32 {
    let key = b"NodeCount";
    db.get(key)
        .unwrap()
        .map(|bytes_vec| {
            assert_eq!(bytes_vec.len(), 4);
            let mut bytes = [0; 4];
            bytes[0..4].clone_from_slice(&bytes_vec);
            u32::from_be_bytes(bytes)
        })
        .unwrap_or(1)
}

/// Helper method to get leaf element outside a transaction
pub(crate) fn leaf_element<T: MerkleHasher>(
    hasher: Arc<T>,
    db: &sled::Tree,
    index: LeafIndex,
) -> T::Element {
    db.get(index.element_key())
        .unwrap()
        .map(|bytes_vec| {
            let mut bytes = &bytes_vec[..];
            hasher.read_element(&mut bytes).unwrap()
        })
        .unwrap()
}
